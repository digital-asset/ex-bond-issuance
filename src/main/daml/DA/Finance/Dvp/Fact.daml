--
-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

daml 1.2 module DA.Finance.Dvp.Fact where



import DA.Finance.Account.Fact
import DA.Finance.Asset.Fact
import DA.Finance.Asset.Transfer.Bilateral
import DA.Finance.Types
import DA.Finance.Utility
import DA.Map
import DA.List


data SettlementStatus = Instructed | Pending | Settled deriving (Eq, Show)

-- DvpFact
-- A template capturing data for what a buyer needs to exchange with a seller
-- on a settlementDate (or later). To actually effectuate the settlemnet, a
-- Settlement Method is to be used (see e.g., the DvpRule in the SettlementMethod
-- folder)
template DvpFact
  with
    tradeId: Text
    status: SettlementStatus
    buyer: Party
    seller: Party
    settlementDate: Optional Date
    paymentLegs: Map InstrumentKey Decimal
    deliveryLegs: Map InstrumentKey Decimal
    observers: [Party]
  where
    ensure dvpFactIsValid this
    signatory buyer, seller
    observer observers

-- DvpFactRequest
template DvpFactRequest
  with
    tradeId: Text
    applicant: Party
    applicantIsBuyer: Bool
    counterparty: Party
    paymentLegs: Map InstrumentKey Decimal
    deliveryLegs: Map InstrumentKey Decimal
    settlementDate: Optional Date
    observers: [Party]
  where
    let buyer = if applicantIsBuyer then applicant else counterparty
        seller = if not applicantIsBuyer then applicant else counterparty
        dvpFact = DvpFact with tradeId; status = Instructed; buyer; seller; paymentLegs; deliveryLegs; settlementDate; observers
    signatory applicant
    ensure dvpFactIsValid dvpFact
    controller counterparty can
      DvpFactRequest_Accept: ContractId DvpFact
        do create dvpFact
      DvpFactRequest_Reject: ()
        do return ()
    controller applicant can
      DvpFactRequest_Cancel: ()
        do return ()

-- Utility functions
setDvpFactStatus (buyer: Party) (seller: Party) (dvpFactCid: ContractId DvpFact) (status: SettlementStatus) =
  do
    dvpFact <- fetch dvpFactCid
    archive dvpFactCid
    create dvpFact with buyer; seller; status

allStrictPositive (m: Map InstrumentKey Decimal) = all (\(instrumentKey, assetQuantity) -> assetQuantity > 0.0) (toList m)

dvpFactIsValid (c: DvpFact) =
  let mapsAreDisjoint (m1: Map InstrumentKey Decimal) (m2: Map InstrumentKey Decimal) = size (merge (\ _k _a -> None) (\ _k _a -> None) (\ _k _a _b -> Some True) m1 m2) == 0
      dedupe (m: Map InstrumentKey Decimal) = fromList (dedupOn (\(instrumentKey, assetQuantity) ->  instrumentKey) (toList m))
  in
  allStrictPositive c.deliveryLegs
    && allStrictPositive c.paymentLegs
    && mapsAreDisjoint c.paymentLegs c.deliveryLegs
    && dedupe c.paymentLegs == c.paymentLegs
    && dedupe c.deliveryLegs == c.deliveryLegs
    && (size c.paymentLegs > 0 || size c.deliveryLegs > 0)

dvpFactMatches
  (buyer: Party)
  (seller: Party)
  (dvpFactCid: ContractId DvpFact)
  =
  do
    dvpFact <- fetch dvpFactCid
    assertMsg "dvpFact parties matches" (dvpFact.buyer == buyer && dvpFact.seller == seller)
    return dvpFact

assetMatchesLeg ((assetFactCid, (instrumentKey, assetQuantity)): (ContractId AssetFact, (InstrumentKey, Decimal))) =
  do
    assetFact <- fetch assetFactCid
    assertMsg
        "assetFact matches leg"
      (    assetFact.accountId.provider == instrumentKey.provider
        && assetFact.assetId.instrumentId == instrumentKey.instrumentId
        && assetFact.quantity == assetQuantity
      )

assetsAndAccountsMatchLegs
  (legs1: Map InstrumentKey Decimal)
  (legs1AssetCids: [(ContractId AssetFact)])
  (legs2: Map InstrumentKey Decimal)
  (legs2TargetAccountCids: [(ContractId AccountFact)]) =
  do
    assertMsg "assetCids matches legs1" (length legs1AssetCids == size legs1)
    mapA assetMatchesLeg (zip legs1AssetCids (toList legs1))
    -- note that the account is checked during transfers of assets
    assertMsg "target accounts have same length as legs2" (length legs2TargetAccountCids == size legs2)

transferAssets
  ((assetTransferRuleCid, assetFactCid, accountFactCid): (ContractId AssetTransferRule, ContractId AssetFact, ContractId AccountFact))
  = do
  account <- fetch accountFactCid
  transferReq <- exercise assetTransferRuleCid $ AssetTransferRule_RequestTransfer assetFactCid account.accountId.owner account.accountId.identifier
  exercise transferReq $ AssetTransferRuleRequest_Accept accountFactCid

transferAssetsWithOneTime
  ((assetTransferRuleCid, assetFactCid, accountFactCid): (ContractId OneTimeAssetTransferRule, ContractId AssetFact, ContractId AccountFact))
  = do
  account <- fetch accountFactCid
  transferReq <- exercise assetTransferRuleCid $ OneTimeAssetTransferRule_RequestTransfer assetFactCid account.accountId.owner account.accountId.identifier
  exercise transferReq $ AssetTransferRuleRequest_Accept accountFactCid

atomicSwap
  (oneTimePaymentTransferRuleCids: [(ContractId OneTimeAssetTransferRule)])
  (paymentFactCids: [(ContractId AssetFact)])
  (paymentTargetAccountFactCids: [(ContractId AccountFact)])
  (deliveryTransferRuleCids: [(ContractId AssetTransferRule)])
  (deliveryFactCids: [(ContractId AssetFact)])
  (deliveryTargetAccountFactCids: [(ContractId AccountFact)])
  =
  do
    deliveryFactCids <- mapA (transferAssets) (zip3 deliveryTransferRuleCids deliveryFactCids deliveryTargetAccountFactCids)
    paymentFactCids <- mapA (transferAssetsWithOneTime) (zip3 oneTimePaymentTransferRuleCids paymentFactCids paymentTargetAccountFactCids)
    return (paymentFactCids, deliveryFactCids)

atomicSwapWithChecks
  (checkSettlementDateIsDue: Bool)
  (buyer: Party)
  (seller: Party)
  (dvpFactCid: ContractId DvpFact)
  (oneTimePaymentTransferRuleCids: [(ContractId OneTimeAssetTransferRule)])
  (paymentFactCids: [(ContractId AssetFact)])
  (paymentTargetAccountFactCids: [(ContractId AccountFact)])
  (deliveryTransferRuleCids: [(ContractId AssetTransferRule)])
  (deliveryFactCids: [(ContractId AssetFact)])
  (deliveryTargetAccountFactCids: [(ContractId AccountFact)])
  =
  do
    -- Check DvpFact
    dvpFact <- dvpFactMatches buyer seller dvpFactCid
    assertMsg "has been allocated" (dvpFact.status == Instructed)
    dvpFactCid <- setDvpFactStatus buyer seller dvpFactCid Settled
    -- Check allocate
    assetsAndAccountsMatchLegs dvpFact.paymentLegs paymentFactCids dvpFact.deliveryLegs deliveryTargetAccountFactCids
    -- Check settle
    assetsAndAccountsMatchLegs dvpFact.deliveryLegs deliveryFactCids dvpFact.paymentLegs paymentTargetAccountFactCids
    -- Check time
    if checkSettlementDateIsDue then isDue dvpFact.settlementDate else return ()
    -- Atomic swap
    (paymentFactCids, deliveryFactCids) <- atomicSwap
      oneTimePaymentTransferRuleCids
      paymentFactCids
      paymentTargetAccountFactCids
      deliveryTransferRuleCids
      deliveryFactCids
      deliveryTargetAccountFactCids
    return (dvpFactCid, paymentFactCids, deliveryFactCids)
