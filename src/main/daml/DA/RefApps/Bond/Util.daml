--
-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module DA.RefApps.Bond.Util where

import DA.Finance.Asset
import DA.Finance.Asset.Settlement

import DA.List
import DA.Finance.Types (Account)

data BondBundleData = BondBundleData {
  assetDepositCid: ContractId AssetDeposit
, assetFungibleCid: ContractId AssetDeposit
, bondSettlementCid: ContractId AssetSettlementRule
, bondAccount: Account
, cashSettlementCid: ContractId AssetSettlementRule
, cashAccount: Account
, assetLabel: Text
} deriving (Eq, Show)

-- Utility function to combine a set of AssetFacts so that it results in a single
-- AssetFact which has the required quantity and the rest.
mergeForQuantity: ContractId AssetDeposit ->
                  AssetDeposit ->
                  [ContractId AssetDeposit] ->
                  Decimal ->
                  ContractId AssetDeposit ->
                  Update (Optional (ContractId AssetDeposit, [ContractId AssetDeposit]))
mergeForQuantity firstAssetCid firstAsset otherAssets requiredQuantity assetFungible
  | firstAsset.asset.quantity == requiredQuantity = do return (Some (firstAssetCid, otherAssets))
  | firstAsset.asset.quantity > requiredQuantity = do
    let rest = firstAsset.asset.quantity - requiredQuantity
    withRequiredQuantity :: remainder <- exercise assetFungible $ AssetDeposit_Split [requiredQuantity, rest]
    return (Some (withRequiredQuantity, remainder <> otherAssets))
  | otherwise =
    if null otherAssets then
      -- There's no subsequent asset to merge into the firstAsset, it means that the sum is lower than the required quantity.
      pure None
    else do
      mergedAssetCid <- exercise assetFungible $ AssetDeposit_Merge [firstAssetCid, head otherAssets]
      mergedAsset <- fetch mergedAssetCid
      mergeForQuantity mergedAssetCid mergedAsset (tail otherAssets) requiredQuantity assetFungible
