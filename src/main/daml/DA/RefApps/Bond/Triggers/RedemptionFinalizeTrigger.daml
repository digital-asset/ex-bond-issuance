--
-- Copyright (c) 2019, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

daml 1.2

module DA.RefApps.Bond.Triggers.RedemptionFinalizeTrigger where

import DA.RefApps.Bond.Test.FullScenario qualified as MarketSetup
import DA.RefApps.Bond.Redemption
import DA.Finance.Fact.Asset
import DA.Finance.Rule.Asset
import DA.RefApps.Bond.Roles.IssuerRole
import DA.RefApps.Bond.ContractUtils
import Daml.Trigger
import Daml.Trigger.Assert
import DA.Assert
import DA.List
import DA.Next.Map qualified as Map
import DA.Foldable hiding (length)


redemptionFinalizeTrigger : Trigger ()
redemptionFinalizeTrigger = Trigger
  { initialize = const ()
  , updateState = \_ _ _ -> ()
  , rule = redemptionFinalizeRule
  , registeredTemplates = RegisteredTemplates [
      registeredTemplate @RedemptionFinalizeBotTrigger,
      registeredTemplate @AssetSettlement,
      registeredTemplate @AssetDeposit,
      registeredTemplate @AssetFungible
    ]
  , heartbeat = None
  }

redemptionFinalizeRule : Party -> ACS -> Time -> Map.Map CommandId [Command] -> () -> TriggerA ()
redemptionFinalizeRule party activeContracts _ _ () = do
  let redemptionFinalizeTriggers = getContracts @RedemptionFinalizeBotTrigger activeContracts
      assetSettlements = getContracts @AssetSettlement activeContracts
      assetDeposits = getContracts @AssetDeposit activeContracts
      assetFungibles = getContracts @AssetFungible activeContracts

  forA_ redemptionFinalizeTriggers $ \(triggerCid, trigger) -> do
    let assetSettlementCid =
          findAsset'
            trigger.cashAccountProviders
            trigger.issuer
            assetSettlements
        assetFungibleCid =
          findAsset'
            trigger.cashAccountProviders
            trigger.issuer
            assetFungibles
        assetDepositCids =
          filterContractIds
            (\p -> p.asset.id.label == trigger.cashAssetId.label &&
                   p.asset.id.version == trigger.cashAssetId.version)
            assetDeposits
    dedupExercise triggerCid $ RedemptionFinalizeBotTrigger_Finalize
        assetDepositCids
        assetSettlementCid
        assetFungibleCid

-- Tests ---------------------------

testFinalizeTrigger: Scenario ()
testFinalizeTrigger = scenario do
  auctionAgent <- getParty "AuctionAgent"
  issuer <- getParty "Issuer"
  csd <- getParty "CSD"

  issuance <-
    MarketSetup.setupIssuance
  progress <-
    MarketSetup.startAuction issuance
  (settleRequests, remainedBond) <-
    MarketSetup.finalizeAuction progress
  assetsForRedemption <-
    MarketSetup.doSettlement issuance settleRequests progress
  redemptionFinalize <-
    redeem csd issuer issuance settleRequests assetsForRedemption remainedBond

  let activeContracts =
          toACS redemptionFinalize <>
          toACS issuance.cashAssets.issuerCashDepositCid <>
          toACS issuance.rules.issuerCashSettlementCid <>
          toACS issuance.rules.issuerCashFungibleCid
  commands <-
    testRule redemptionFinalizeTrigger issuer activeContracts Map.empty ()
  let flattenedCommands = flattenCommands commands
  length flattenedCommands === 1
  assertExerciseCmd flattenedCommands $ \(cid, choiceArg) -> do
    assertEq cid redemptionFinalize
    assertEq choiceArg (RedemptionFinalizeBotTrigger_Finalize with
      cashAssetDepositCids = [issuance.cashAssets.issuerCashDepositCid]
      cashAssetSettlementCid = issuance.rules.issuerCashSettlementCid
      cashAssetFungibleCid = issuance.rules.issuerCashFungibleCid)

testNoFinalizeTrigger: Scenario ()
testNoFinalizeTrigger = scenario do
  auctionAgent <- getParty "AuctionAgent"
  issuer <- getParty "Issuer"
  csd <- getParty "CSD"

  issuance <-
    MarketSetup.setupIssuance
  progress <-
    MarketSetup.startAuction issuance
  (settleRequests, remainedBond) <-
    MarketSetup.finalizeAuction progress
  assetsForRedemption <-
    MarketSetup.doSettlement issuance settleRequests progress
  redemptionFinalize <-
    redeem csd issuer issuance settleRequests assetsForRedemption remainedBond

  let activeContracts =
          toACS issuance.cashAssets.issuerCashDepositCid <>
          toACS issuance.rules.issuerCashSettlementCid <>
          toACS issuance.rules.issuerCashFungibleCid
  commands <-
    testRule redemptionFinalizeTrigger issuer activeContracts Map.empty ()
  let flattenedCommands = flattenCommands commands
  length flattenedCommands === 0

redeem: Party -> Party -> MarketSetup.TestIssuance -> MarketSetup.SettleRequests -> MarketSetup.AssetsForRedemption -> ContractId AssetDeposit -> Scenario (ContractId RedemptionFinalizeBotTrigger)
redeem csd issuer issuance settleRequests assetsForRedemption remainedBondDeposit = do
  (request, leftOverSettlementChain) <-
    submit issuer do
      redeemRequest <- exercise issuance.roles.issuerRoleCid $ IssuerRole_Redeem issuance.fixedRateBondFactCid
      otherParticipantReq <- fetch settleRequests.otherSettleReqCid
      otherSettleReq <- fetch $ head otherParticipantReq.settleRequestCids
      return (redeemRequest, otherSettleReq.bondSettlementChainCid)
  submit csd do
    calc <- exercise request RedemptionRequest_Accept
    exercise calc $ RedemptionCalculationBotTrigger_Start
      [assetsForRedemption.bank1RedemptionPayoutInfoCid, assetsForRedemption.bank2RedemptionPayoutInfoCid, assetsForRedemption.bank3RedemptionPayoutInfoCid]
      [remainedBondDeposit]
